repeat task.wait() until game:IsLoaded()

--Locals
local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local Character = Players.LocalPlayer.Character
local WaitingToTp = false
local GreggCoin,RealCoin = false,nil
local oldTick = tick()
local BestDungeon,BestDifficulty = "nil","Insane"
local NameHideName,NameHideTitle = "",""
local RemoteModule
local LastplayerPos,StuckTime = Vector3.zero,0
local PlayerGui = Players.LocalPlayer.PlayerGui
local OldName,OldTitle

-- UI Load Detection and Auto-Rejoin System
local UI_LOAD_TIMEOUT = 999999999999999999999 -- seconds to wait for UI to load
local AUTO_REJOIN_INTERVAL = 600 -- 10 minutes in seconds
local lastRejoinTime = tick()
local uiLoaded = false
local rejoinEnabled = false
local loadAttempts = 0
local maxLoadAttempts = 3

--Tables
local Settings = {
    AutoFarm={Enabled=true,Delay=2,Distance=6,UseSkills=true,RaidFarm=false},
    Dungeon={Enabled=true,EnabledBest=true,Name="",Diffculty="",Mode="Normal",RaidEnabled=false,RaidName="",Tier="1"},
    AutoSell = {Enabled = false,Raritys = {},ItemTypes = {}};
    Misc={
        AutoRetry=false,
        AutoReturnLobby=true,
        GetGreggCoin=false,
        NameHide=false,
        RejoinIfStuck=true,
        RejoinStuckDelay=30,
        AutoRejoin=false, -- NEW: Toggle for periodic rejoin
        RejoinOnUIFail=true -- NEW: Rejoin if UI fails to load
    },
    DebugMode=false,
}
local DungeonLevels = {
    ["0"] = {["Dungeon"] = "Desert Temple", ["Easy"] = 0, ["Medium"] = 5, ["Hard"] = 15},
    ["30"] = {["Dungeon"] = "Winter Outpost", ["Easy"] = 30, ["Medium"] = 40, ["Hard"] = 50},
    ["60"] = {["Dungeon"] = "Pirate Island", ["Insane"] = 60, ["Nightmare"] = 65},
    ["70"] = {["Dungeon"] = "King's Castle", ["Insane"] = 70, ["Nightmare"] = 75},
    ["80"] = {["Dungeon"] = "The Underworld", ["Insane"] = 80, ["Nightmare"] = 85},
    ["90"] = {["Dungeon"] = "Samurai Palace", ["Insane"] = 90, ["Nightmare"] = 95},
    ["100"] = {["Dungeon"] = "The Canals", ["Insane"] = 100, ["Nightmare"] = 105},
    ["110"] = {["Dungeon"] = "Ghastly Harbor", ["Insane"] = 110, ["Nightmare"] = 115},
    ["120"] = {["Dungeon"] = "Steampunk Sewers", ["Insane"] = 120, ["Nightmare"] = 125},
    ["135"] = {["Dungeon"] = "Orbital Outpost", ["Insane"] = 135, ["Nightmare"] = 140},
    ["150"] = {["Dungeon"] = "Volcanic Chambers", ["Insane"] = 150, ["Nightmare"] = 155},   
    ["160"] = {["Dungeon"] = "Aquatic Temple", ["Insane"] = 160, ["Nightmare"] = 165},
    ["170"] = {["Dungeon"] = "Enchanted Forest", ["Insane"] = 170, ["Nightmare"] = 175},
    ["180"] = {["Dungeon"] = "Northern Lands", ["Insane"] = 180, ["Nightmare"] = 185},
    ["190"] = {["Dungeon"] = "Gilded Skies", ["Insane"] = 190, ["Nightmare"] = 195},
    ["200"] = {["Dungeon"] = "Yokai Peak", ["Insane"] = 200, ["Nightmare"] = 205},
    ["210"] = {["Dungeon"] = "Abyssal Void", ["Insane"] = 210, ["Nightmare"] = 215},
}
local Raritys = {
    ["Legendary"]=Color3.fromRGB(244, 154, 9);
    ["Epic"]=Color3.fromRGB(146, 70, 159);
    ["Rare"]=Color3.fromRGB(75, 77, 195);
    ["Uncommon"]=Color3.fromRGB(91, 194, 80);
    ["Common"]=Color3.fromRGB(152, 152, 152);
}
local RemoteCodes = {}
local Functions = {}

--Functions
Players.LocalPlayer.CharacterAdded:Connect(function(char)
    Character = char
    repeat task.wait() until Character:FindFirstChild("HumanoidRootPart")
end)

function Functions:GetInventoryItems()
    local tbl = {}
    for i,v in pairs(Players.LocalPlayer.PlayerGui.sellShop.Frame.innerFrame.rightSideFrame.ScrollingFrame:GetChildren()) do
        if v:IsA("ImageLabel") and v:FindFirstChild("itemType") and v.itemType:FindFirstChild("uniqueItemNum") then
            local Item = {["index"]=v:FindFirstChild("itemType"):FindFirstChild("uniqueItemNum").Value,["rarity"]="";["itemType"]=v:FindFirstChild("itemType").Value}
            for i2,v2 in pairs(Raritys) do
                if v.ImageColor3 == v2 then
                    Item["rarity"] = i2
                end
            end
            table.insert(tbl,Item)
        end
    end
    return tbl
end

function Functions:DoSkills(RepeatCount)
    for i, v in pairs(game:GetService("Players").LocalPlayer.Backpack:GetChildren()) do
        for i = 0,RepeatCount do
            task.spawn(function()
                if v:FindFirstChild("cooldown") and v.cooldown.Value and (v:FindFirstChild("abilityEvent") or v:FindFirstChild("spellEvent")) then
                    (v:FindFirstChild("abilityEvent") or v:FindFirstChild("spellEvent")):FireServer()
                elseif v:FindFirstChild("cooldown") and v.cooldown.Value then
                    game:GetService("ReplicatedStorage"):WaitForChild("dataRemoteEvent"):FireServer({[1] = {["\t"] = v},[2] = RemoteCodes["Abilities"]})
                end
            end)
        end
    end
    task.wait()
end

function Functions:Teleport(Cframe)
    if not Character:FindFirstChild("HumanoidRootPart") then return end
    LastplayerPos = Character:GetPivot().p
    if WaitingToTp == true then return end
    local bodyPosition = Character.HumanoidRootPart:FindFirstChildOfClass("BodyPosition")
    local bodyGyro = Character.HumanoidRootPart:FindFirstChildOfClass("BodyGyro")
    if not Character.HumanoidRootPart:FindFirstChildOfClass("BodyGyro") then
        bodyGyro = Instance.new("BodyGyro")
        bodyGyro.MaxTorque = Vector3.new(400000, 400000, 400000);bodyGyro.CFrame = Character.HumanoidRootPart.CFrame;bodyGyro.D = 500;bodyGyro.Parent = Character.HumanoidRootPart
    end
    if not Character.HumanoidRootPart:FindFirstChildOfClass("BodyPosition") then
        bodyPosition = Instance.new("BodyPosition")
        bodyPosition.MaxForce = Vector3.new(400000, 400000, 400000);bodyPosition.Position = Cframe.Position;bodyPosition.D = 300;bodyPosition.Parent = Character.HumanoidRootPart;Character.HumanoidRootPart.Velocity = Vector3.zero
    end
    local oldTime = tick()
    WaitingToTp = true
    Character.HumanoidRootPart.Anchored = false
    repeat task.wait()
        if Character:FindFirstChild("HumanoidRootPart") and bodyPosition ~= nil and bodyGyro ~= nil then
            Character:PivotTo(CFrame.new(Cframe.p + Vector3.new(0, Settings.AutoFarm.Distance * 2, 0))* CFrame.Angles(math.rad(90), 0, 0))
            bodyPosition.Position = Cframe.Position + Vector3.new(0, Settings.AutoFarm.Distance * 2, 0)
            bodyGyro.CFrame = CFrame.new(Character:GetPivot().p, Cframe.Position) * CFrame.Angles(math.rad(90), 0, 0)
        end
    until tick() - oldTime >= Settings.AutoFarm.Delay or not Character:FindFirstChild("HumanoidRootPart")
    WaitingToTp = false
    if Character:FindFirstChild("HumanoidRootPart") then
        Character.HumanoidRootPart.Anchored = true
        bodyPosition:Destroy()
    end
end

function Functions:GetEnemys()
    if not workspace:FindFirstChild("dungeon") then 
        return workspace:FindFirstChild("enemies"):GetChildren()
    end
    for i, v in pairs(workspace.dungeon:GetChildren()) do
        if v:FindFirstChild("enemyFolder") and v.enemyFolder:FindFirstChildOfClass("Model") then
            return v.enemyFolder:GetChildren()
        end
    end
    return nil
end

function Functions:GetClosestEnemy()
    if not Character:FindFirstChild("HumanoidRootPart") then return end
    if Functions:GetEnemys() == nil then return end

    local closestEnemy = nil
    local highestHealthEnemy = nil
    local shortestDistance = math.huge
    local maxHealth = -math.huge
    for _, v in pairs(Functions:GetEnemys()) do
        local enemyPosition = v:FindFirstChild("HumanoidRootPart") and v.HumanoidRootPart.Position
        local enemyHumanoid = v:FindFirstChild("Humanoid")
        if enemyPosition and enemyHumanoid then
            local distance = (Character.HumanoidRootPart.Position - enemyPosition).Magnitude
            if distance < shortestDistance or (distance == shortestDistance and enemyHumanoid.MaxHealth > maxHealth) then
                shortestDistance = distance
                closestEnemy = v
                maxHealth = enemyHumanoid.MaxHealth
            end
        end
    end

    return closestEnemy
end

function Functions:GetBestDungeon()
    local highestLevelDungeon = 0
    for i, v in pairs(DungeonLevels) do
        if Players.LocalPlayer.leaderstats.Level.Value >= tonumber(i) then
            if tonumber(i) > highestLevelDungeon then
                highestLevelDungeon = tonumber(i)
                if v["Nightmare"] and Players.LocalPlayer.leaderstats.Level.Value >= v["Nightmare"] then
                    BestDungeon = v["Dungeon"];BestDifficulty = "Nightmare"
                elseif v["Insane"] and Players.LocalPlayer.leaderstats.Level.Value >= v["Insane"] then
                    BestDungeon = v["Dungeon"];BestDifficulty = "Insane"
                elseif v["Hard"] and Players.LocalPlayer.leaderstats.Level.Value >= v["Hard"] then
                    BestDungeon = v["Dungeon"];BestDifficulty = "Hard"
                elseif v["Medium"] and Players.LocalPlayer.leaderstats.Level.Value >= v["Medium"] then
                    BestDungeon = v["Dungeon"];BestDifficulty = "Medium"
                elseif v["Easy"] and Players.LocalPlayer.leaderstats.Level.Value >= v["Easy"] then
                    BestDungeon = v["Dungeon"];BestDifficulty = "Easy"
                end
            end
        end
    end
end

-- NEW: Function to check if UI loaded properly
function Functions:IsUILoaded()
    if not Library or not Window then return false end
    
    local success, result = pcall(function()
        return Window.Enabled and Library.Flags ~= nil
    end)
    
    return success and result
end

-- NEW: Function to rejoin game
function Functions:RejoinGame()
    if Library and Library.Notify then
        Library:Notify({
            Title = "Rejoining Game",
            Text = "UI failed to load or auto-rejoin triggered",
            Duration = 3
        })
    end
    
    task.wait(2)
    
    if queue_on_teleport then
        queue_on_teleport('loadstring(game:HttpGet("https://raw.githubusercontent.com/lovelye1/smegmasd/refs/heads/main/SIGM"))()')
    end
    
    game:GetService("TeleportService"):Teleport(2414851778, Players.LocalPlayer)
end

--Grab Codes
if getupvalue ~= nil then
    repeat task.wait() until game:GetService("ReplicatedStorage"):FindFirstChild("Utility") and game:GetService("ReplicatedStorage").Utility:FindFirstChild("BridgeNet2") and game:GetService("ReplicatedStorage").Utility.BridgeNet2:FindFirstChild("Client") and game:GetService("ReplicatedStorage").Utility.BridgeNet2.Client:FindFirstChild("ClientIdentifiers")
    RemoteModule = require(game:GetService("ReplicatedStorage").Utility.BridgeNet2.Client.ClientIdentifiers)
    for i,v in pairs(getupvalue(RemoteModule["deser"],2)) do
        RemoteCodes[v] = i
    end
else
    RemoteCodes={["DungeonRetryBridge"]="/",["CharacterSelection"]="M",["PartySystem"]="d",["Cutscene"]="\184",["Intro"]="5",["DungeonHandler"]=";",["Abilities"]="G"}
end

repeat task.wait() 
until Players.LocalPlayer and Players.LocalPlayer.PlayerGui
for i=0,5 do task.wait(.2)
    if Players.LocalPlayer.PlayerGui:FindFirstChild("CharacterSelection") and not Character then
        game:GetService("ReplicatedStorage"):WaitForChild("dataRemoteEvent"):FireServer({[1] = {[1] = "\1",[2] = {["\3"] = "select",["characterIndex"] = 1}},[2] = RemoteCodes["CharacterSelection"]})
        game:GetService("ReplicatedStorage"):WaitForChild("dataRemoteEvent"):FireServer({[1] = {[1] = "\1"},[2] = RemoteCodes["Intro"]})
    end
end

-- Robust library loading with retry mechanism
local Library
local function loadLibrarySafely()
    while loadAttempts < maxLoadAttempts do
        local success, result = pcall(function()
            return loadstring(game:HttpGet("https://gist.githubusercontent.com/VertigoCool99/282c9e98325f6b79299c800df74b2849/raw/d9efe72dc43a11b5237a43e2de71b7038e8bb37b/library.lua"))()
        end)
        
        if success and result then
            return result
        else
            loadAttempts = loadAttempts + 1
            warn("Library load attempt " .. loadAttempts .. " failed, retrying...")
            task.wait(2)
        end
    end
    return nil
end

-- Load library with error handling
Library = loadLibrarySafely()

if not Library then
    -- If library still fails to load, rejoin immediately
    game:GetService("TeleportService"):Teleport(2414851778, Players.LocalPlayer)
    return
end

-- Create window with error handling
local Window
local success, err = pcall(function()
    Window = Library:CreateWindow({Title=" Dungeon Quest",TweenTime=.15,Center=true})
    
    if not Window then
        error("Window creation failed")
    end
    
    return Window
end)

if not success then
    warn("UI Creation Failed: " .. tostring(err))
    if Settings.Misc.RejoinOnUIFail then
        Functions:RejoinGame()
    end
    return
end
   
local FarmingTab = Window:AddTab("Farming")
local MiscTab = Window:AddTab("Misc")

local NormalFarm = FarmingTab:AddLeftGroupbox("Auto Farm")
local DungeonCreateGroup = FarmingTab:AddRightGroupbox("Dungeon Creation")
local SettingsGroup = FarmingTab:AddLeftGroupbox("Settings")
local AutoSellGroup = MiscTab:AddLeftGroupbox("Auto Sell")
local NameHideGroup = MiscTab:AddRightGroupbox("Name Hider")
local RejoinStuckGroup = MiscTab:AddRightGroupbox("Rejoin When Stuck")

--Farming Start
local NormalFarmToggle = NormalFarm:AddToggle("NormalFarmToggle",{Text = "Enabled",Default = false,Risky = false})
NormalFarmToggle:OnChanged(function(value)
    Settings.AutoFarm.Enabled = value
end)
local UseSkillsToggle = NormalFarm:AddToggle("UseSkillsToggle",{Text = "Use Skills",Default = false,Risky = false})
UseSkillsToggle:OnChanged(function(value)
    Settings.AutoFarm.UseSkills = value
end)
NormalFarm:AddDivider()
local TeleportDelaySlider = NormalFarm:AddSlider("TeleportDelaySlider",{Text = "Teleport Delay",Default = 2,Min = 1,Max = 4,Rounding = 1})
TeleportDelaySlider:OnChanged(function(Value)
    Settings.AutoFarm.Delay = Value
end)
local DistanceSlider = NormalFarm:AddSlider("DistanceSlider",{Text = "Distance",Default = 6,Min = 0,Max = 10,Rounding = 0})
DistanceSlider:OnChanged(function(Value)
    Settings.AutoFarm.Distance = Value
end)
--Farming End
--DungeonCreateGroup Start
local AutoCreateBestToggle = DungeonCreateGroup:AddToggle("AutoCreateBestToggle",{Text = "Auto Create Best",Default = false,Risky = false})
AutoCreateBestToggle:OnChanged(function(value)
    Settings.Dungeon.EnabledBest = value
end)
local AutoCreateToggle = DungeonCreateGroup:AddToggle("AutoCreateToggle",{Text = "Auto Create",Default = false,Risky = false})
AutoCreateToggle:OnChanged(function(value)
    Settings.Dungeon.Enabled = value
end)
local AutoCreateDungeonNameDrop = DungeonCreateGroup:AddDropdown("AutoCreateDungeonNameDrop",{Text = "Dungeon", AllowNull = false,Values = {"Desert Temple","Winter Outpost","Pirate Island","King's Castle","The Underworld","Samurai Palace","The Canals","Ghastly Harbor","Steampunk Sewers","Orbital Outpost","Volcanic Chambers","Aquatic Temple","Enchanted Forest","Northen Lands","Gilded Skies","Yokai Peak","Abyssal Void"},Default=BestDungeon,Multi = false,})
AutoCreateDungeonNameDrop:OnChanged(function(Value)
    Settings.Dungeon.Name = Value
end)
local AutoCreateDungeonDiffcultyDrop = DungeonCreateGroup:AddDropdown("AutoCreateDungeonDiffcultyDrop",{Text = "Diffculty", AllowNull = false,Values = {"Insane","Nightmare"},Default=BestDifficulty,Multi = false,})
AutoCreateDungeonDiffcultyDrop:OnChanged(function(Value)
    Settings.Dungeon.Diffculty = Value
end)
local AutoCreateDungeonModeDrop = DungeonCreateGroup:AddDropdown("AutoCreateDungeonModeDrop",{Text = "Mode", AllowNull = false,Values = {"Normal","Hardcore"},Default="Normal",Multi = false,})
AutoCreateDungeonModeDrop:OnChanged(function(Value)
    Settings.Dungeon.Mode = Value
end)
DungeonCreateGroup:AddDivider()
local AutoCreateRaidToggle = DungeonCreateGroup:AddToggle("AutoCreateRaidToggle",{Text = "Auto Create Raid",Default = false,Risky = false})
AutoCreateRaidToggle:OnChanged(function(value)
    Settings.Dungeon.RaidEnabled = value
end)
local AutoCreateDungeonNameRaidDrop = DungeonCreateGroup:AddDropdown("AutoCreateDungeonNameRaidDrop",{Text = "Raid Dungeon", AllowNull = false,Values = {"Hela Raid","Goliath Raid"},Default=BestDunge
